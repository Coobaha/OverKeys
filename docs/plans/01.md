# PROMPT EXECUTION GUIDELINES

ALWAYS FOLLOW THIS:

When executing prompts, follow these steps meticulously to ensure consistency and correctness:

1. Open **@docs/plans/01.md** and identify any prompts not marked as completed.
2. For each incomplete prompt:
    - keep the prompt section in this doc up to date if needed or provide details, but don't be too verbose, instead focus on the high-level steps.
    - Double-check if it is truly unfinished (if uncertain, ask for clarification, consult jj diff).
        - If you confirm it is already done, skip it. found != completed, this means the issue/step/prompt is still open.
        - if you put Todo/Fallbacks in the code - it is considered as not completed.
    - Otherwise, implement it as described.
        - Never deprecate changes or create fallbacks if a developer didn't ask it.
        - Always prefer assertions to fallbacks and default values.
        - Assert correct state.
        - Create new prompts for any new bigger tasks that arise during implementation following prompt creation guidelines.
    - Make sure the tests pass, and the program builds/runs: (`mise build -> mise test`)
        - IMPORTANT: Always use
          `mise` for running tasks - it's superior to manual commands and ensures consistent environment
        - IMPORTANT: Prefer stdlib functions over custom implementations (e.g., `time.ParseDuration` vs custom parsing)
    - `jj diff`, check that it makes sense and matches what we were aiming for
    - **CRITICAL**: In multi-repo setup, commit changes in BOTH locations:
        1. **Review changes**: `jj diff`
        2. **Split if needed**: Use `jj split -m` to commit only relevant changes (avoid mixing unrelated changes)
        3. **Commit**: `jj describe -m "commit message"` then `jj new`
        4. **Do not use co-authored or generated with claude in commit messages**
        5. NEVER commit docs/plans/*.md, only relevant changes. 
    - Update **@docs/plans/01.md** to mark this prompt as completed.
        - keep this doc up to date if needed, but don't be too verbose, instead focus on the high-level steps.
3. After you finish each prompt, pause and wait for user review or feedback.
4. Repeat with the next unfinished prompt as directed by the user.

IMPORTANT Prompt creation guidelines:

Create a prompt in this document to implement the necessary work that agent will execute.

- Use the following format:
  dont use bold instead use CAPSWORD and emojis to highlight important parts
  ```markdown
  # Prompt <index from 1>: <short descriptive title for the prompt>
  <:optional: description of the prompt>
  <:optional: critical context or details that are relevant to the prompt or constraints>
  <:optional: goal of the prompt>
  - [ ] <description of the change>
    - [ ] <:optional: subtask 1>
  ```

Ensure each prompt is clear and actionable.

The Pattern: When you have a data type in one package and its primary construction/manipulation logic in another package, they
usually belong together. This is especially true when:

- The logic is tightly coupled to the type
- You're passing awkward parameters to avoid circular imports
- The separate package exists mainly to serve that one type
- Lightweight data types → separate packages (avoid circular deps)
- Heavy business logic → can be co-located with related types
- Construction/validation logic → same package as the type
